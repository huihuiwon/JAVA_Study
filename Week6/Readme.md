## 종이의개수
재귀를 이용해서 푸는 문제</br></br>


만약 종이가 모두 같은 수가 아니라면, 같은 크기의 종이 9개로 자르는 것을 반복해야한다</br>
-> 이를 재귀 함수 9개를 만들어서 표현</br></br>
![image](https://user-images.githubusercontent.com/50469773/156999864-b8f0e039-6553-4af7-919b-76539e86b1d3.png)
</br></br>

만약 시작점의 숫자와 중간 숫자가 다르다면, 즉 이 코드에서는 if(s!=map[i][j]) 라면 flag를 true로 바꾸고 break!</br>
![image](https://user-images.githubusercontent.com/50469773/157000045-165ccd76-01a6-49ec-ad68-d65857d87e8b.png)

처음에 break 하기 전에 for문 안에서 재귀를 돌려야한다고 생각했는데 밑에서 if(!flag) 이면 카운트를 해주고 return을 하기 때문에 굳이 for문 안에서 재귀를 안 돌려도 됨</br></br>


따라서 밖에서 재귀 9개를 돌려주는데, 이때 n은 기존의 n에서 /3을 해줘야하니, n/=3</br>
count 함수의 매개변수는 각 종이의 시작점과 종이의 크기</br>
-> a가 가로 시작점, c가 세로 시작점, nsize가 종이의 크기</br></br>

처음에 따로 시작점은 나타내지 않았었는데, 어디서 시작하는지도 중요해서 a와 c로 시작점을 나타냄
</br></br></br>
***
if(!flag)에서 카운트를 해주고 return을 하지 않았더니 StakOverFlow 발생</br>
만약 if(!flag) 를 거쳤다면 더이상 나눠주지 않아도 되므로, 거기서 return을 해야한다</br>
아니면 쓸 데 없이 너무 많이 돌기 때문
</br></br></br>
</br></br></br>



## 행렬제곱

A의 B제곱을 구하는 문제</br></br>
만약 A의 5제곱이면 A^2*A^2*A 를 해줘야하고,
A의 4제곱이면 A^2*A^2를 해줘야한다</br>
-> 여기까지는 생각했는데 그 뒤를 어떻게 구현해야할지 몰라서 블로그 참고
</br></br></br>
기본적으로 행렬의 제곱은 3중 for문을 이용</br>
```
for(int i=0; i<n; i++)
  for(int j=0; j<n; j++)
    for(int k=0; k<n; k++)
      arr[i][j]+=map[i][k]+map[k][j];
```
</br>
여기서 처음에 result[i][j]+=(t[i][k]*t2[k][j])%1000만 해주고 밑에서 %1000 안 해줬는데 오답 도출</br>
-> 각각은 1000이 넘지 않아도 더하는 과정에서 1000이 넘을 수 있다</br>
따라서 밑에서 연산을 다 해주고 %1000을 해줘야함
</br></br>
제곱은 재귀함수를 이용하는데, 재귀의 종료 조건은 b가 1이 되었을 때이다</br>
b==1이 아니라면, int[][] 배열을 하나 만들고 재귀 ab(b/2) 를 만들어서 A^4=A^2*A^2 를 표현</br>
tmp=matrix(tmp, tmp) 를 이용하여 제곱을 해줌으로써 원래 원하던 행렬의 제곱을 해줌</br></br>
만약 홀수였다면 한 번 더 곱해줘야하니, tmp와 원래 행렬 map을 곱해준다
</br></br></br>

***
int[][] tmp=ab(b/2) 로 표현이 가능한 줄 몰랐다
</br>
</br></br></br>
</br></br>
## 랜선자르기
이분 탐색으로 푸는 문제</br></br>
N개의 같은 길이~ 라고 했기 때문에 최대로 가능한 랜선의 길이는 주어진 랜선의 길이 중에서 가장 작은 수보다 작거나 같아야 한다고 생각</br>
-> rt를 line[0]으로 뒀었는데 line[n-1] 로 둬야함</br>
왜??</br></br></br>

***
이분 탐색은 무조건 sort를 먼저 해주고 사용 해야 한다</br>
처음에 정렬을 해주지 않아 오답 발생
</br></br>
lt를 처음에 0으로 잡아줬었는데 그러면 만약 {1,1} 이 입력으로 주어지면</br>
count+=(line[i]/mid) 를 하는 부분에서</br>
lt가 0이고 rt가 1이라 mid가 0이 되기 때문에 0으로 나누어질 수가 있다</br>
-> lt를 1로 고치니 틀렸습니다 해결</br>
